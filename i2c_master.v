/*
 * Author: Chance Reimer
 * Purpose: Create I2C Master used for writing and reading addresses from the device. Camera Control Interface (CCI) is built off of fast I2C (40KHz clock)
 *			This master module must be fed a 400KHz clock generated by a master, and must be given the information to send.
 * Notes:	* For writing, this module expects the number of reads and writes to be explicit, i.e, how long until termination
 * 
 * How it works: The input clock is 400 KHz for this module, and the output scl is tied to the clock line only during transmission
 *				 SDA line only changes on negedge of 400kHz clock
 *				 SCL line is tied directly to the 400kHz clock
 *
 * Update:      Just realized that its' 400kHz, not 400MHz, thought that was a bit fast
 */

`define DEBUG
`timescale 1fs/1fs
module i2c_master(input				i_clk,				//input clock to the module @100MHz (or whatever crystal you have on the board)
				  input				reset_n,			//reset for creating a known start condition
				  input		 [7:0]  i_addr_w_rw,		//7 bit address, LSB is the read write bit, with 0 being write, 1 being read
				  input		 [15:0] i_sub_addr,			//contains sub addr to send to slave, partition is decided on bit_sel
				  input				i_sub_len,			//denotes whether working with an 8 bit or 16 bit sub_addr, 0 is 8bit, 1 is 16 bit
				  input				i_byte_len,			//denotes whether a single or sequential read or write will be performed
                  input             read_curr_loc,      //Denotes that sub_addr was already sent, thus will skip in state (read from current location in CCI)
                  input             req_trans,          //denotes when to start a new transaction
                  
                  /** For Reads **/
                  output reg [7:0]  data_out,
                  output reg        valid_out,
				  output    		scl_o,			    //i2c clck line, output by this module, 400 kHz
				  inout				sda_o,				//i2c data line, set to 1'bz when not utilized (resistors will pull it high)
				  output reg		busy,				//denotes whether module is currently driving the bus, active high
                  output reg        nack
				  
				  `ifdef DEBUG
				  ,
				  output reg [3:0] state,
                  output reg       sda_next
				  `endif
				  );
				  
localparam [3:0] IDLE        = 4'd0,
				 START       = 4'd1,
				 SLAVE_ADDR  = 4'd2,
				 SUB_ADDR    = 4'd3,
                 
				 READ		 = 4'd4,
				 WRITE		 = 4'd5,
				 ACK_NACK_RX = 4'd6,
                 ACK_NACK_TX = 4'd7,
				 STOP		 = 4'd9;

`ifndef DEBUG
reg [3:0]  state;
reg [3:0]  next_state;
reg        sda_next;
reg        reg_sda_o;
reg [7:0]  addr;
reg        rw;
reg [15:0] sub_addr;
reg        sub_len;
reg        en_scl;
reg        byte_sent;
reg [2:0]  cntr;
reg [7:0]  byte_sr;
reg        read_sub_addr_sent_flag;
reg [7:0]  data_in_sr;
`endif

always@(posedge i_clk or negedge reset_n) begin
	if(!reset_n) begin
		{busy, addr, sub_addr, sub_len, en_scl} <= 0;
        {byte_sent, cntr, nack, read_sub_addr_sent_flag} <= 0;
        {sda_next} <= 1'bz;
		state <= IDLE;
	end
	else begin
		case(state)
			IDLE: begin
                if(req_trans) begin
                    busy <= 1'b1;
                    state <= START;
                    next_state <= SLAVE_ADDR;
                    addr <= i_addr_w_rw;
                    rw <= i_addr_w_rw[0];
                    sub_addr <= i_bit_sel ? i_sub_addr : {i_sub_addr[7:0], 8'b0};
                    sub_len <= i_sub_len;
                    nack <= 1'b0;
                end
			end
			
            /*
             * Note: for repeated start condition, this code completely releases bus. This is not a problem due to only 1 master in use case,
             *       however, if multiple use cases then issues could occurs
             */
			START: begin
                sda_next <= 1'b0;                           //set start bit for negedge of clock, and toggle for the clock to begin
                en_scl <= 1'b1;                             //enable the clk line
                byte_sr <= read_sub_addr_sent_flag ? addr : {addr[7:1], 1'b0};
                state <= next_state;
			end
			
			SLAVE_ADDR: begin
                if(byte_sent) begin
                    byte_sent <= 1'b0;                      //deassert the flag
                    next_state <= read_sub_addr_sent_flag ? READ : SUB_ADDR;
                    byte_sr <= sub_addr[15:8];              //regardless of sub addr length, higher byte will be sent first
                    state <= ACK_NACK_RX;                   //await for nack_ack
                    sda_next <= 1'bz;                       //release sda line
                end
                else begin
                    {byte_sent, cntr} <= cntr + 1'b1;       //incr cntr, with overflow being caught
                    sda_next <= byte_sr[7];                 //send MSB
                    byte_sr <= {byte_sr[6:0], 1'b0};        //shift out MSB
                end
			end
			
			SUB_ADDR: begin
                if(byte_sent) begin
                    if(sub_len) begin                       //1 for 16 bit
                        next_state <= SUB_ADDR;
                        sub_len <= 1'b0;                    //denote only want 8 bit next time
                        byte_sr <= [7:0];
                    end
                    else begin
                        next_state <= rw ? START : WRITE;   //move to appropriate state
                        read_sub_addr_sent_flag <= 1'b1;    //For dictating state of machine
                        en_scl <= 1'b0;
                    end
                        
                    byte_sent <= 1'b0;                      //deassert the flag
                    state <= ACK_NACK_RX;                   //await for nack_ack
                    sda_next <= 1'bz;                       //release sda line
                end
                else begin
                    {byte_sent, cntr} <= cntr + 1'b1;       //incr cntr, with overflow being caught
                    sda_next <=  byte_sr[7];                //send MSB
                    byte_sr <= {byte_sr[6:0], 1'b0};        //shift out MSB
                end
			end
			
			READ: begin
                if(byte_sent) begin
                    byte_sent <= 1'b0;
                    data_out  <= data_in_sr;
                    valid_out <= 1'b1;
                    
                end
                else begin
                    valid_out <= 1'b0;
                    {byte_sent, cntr} <= cntr + 1'b1;
                    data_in_sr <= {data_in_sr[7:1], sda_o};
                end
			end
			
			WRITE: begin
			end
			
			STOP: begin 
                valid_out <= 1'b0;
                state <= IDLE;                              //reset to IDLE
                read_sub_addr_sent_flag <= 1'b0;            //reset flag
			end
            
            ACK_NACK_RX: begin
                if(!sda_o) begin      //checking for the ack condition
                    state <= next_state;
                    $display("$t, ack encountered", $time);
                end
                else begin
                    nack <= 1'b1;
                    busy <= 1'b0;
                    state <= IDLE;
                end      
            end
			
            ACK_NACK_TX: begin
            end
            
			default:
				state <= IDLE;
		endcase
	end
end

/*
 * Purpose: looking at timing diagram of SDA, it is apparent that the transition occurs on negedge of clk period
 */
always@(negedge i_clk or negedge reset_n) begin
	if(!reset_n) begin
		reg_sda_o < = 1'bz;         //raise to high impedance if not controlling the line
	end
	else begin
        reg_sda_o <= sda_next;
	end
end

//inout cannot be reg
assign sda_o = reg_sda_o;
assign scl_o = en_scl ? i_clk : 1'bz;
endmodule
